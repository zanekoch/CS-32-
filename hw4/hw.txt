2:
This does not work because there is no comparison operator for the class Coord. There must be a comparison operator because the single argument insert compares each item to the next to find the place where the value it is inserting fits correctly. To make this work a comparison operator like < or > (not just == or =) for Coord must be declared.

4b: It would be impossible to print the files recursively without having the second path parameter because there would be no where to buildup the name of the path to print it. This is because directories are essentially trees, and since trees have no backwards pointers it would not be possible to go backwards. 

5a: The time complexity of this algorithm is O(N^3). This is because in side the third nested for-loop, "for (int k = 0; k < N; k++)", there are only fixed-time operations so the time that they take can be approximates to be O(1). These operations are then repeated ~N times per the innermost for loop, and then another N times for each of the two outer for-loops. This means the multiply N by itself 3 times, once for each of the loops, which leads to a O(N^3) time complexity.

5b: The time complexity of this algorithm is O(N^3). THis is because inside the third for-loop, "for (int k = 0; k < N; k++)", there are only fixed-time operations so the time that they take can be approximates to be O(1). These operations are then repeated ~i times per the innermost for loop, and then another N times for the outer 2 loops. Because i is about equal to N this inner for loop is run about N times also. This means you multiply N times itself once giving the time complexity of O(N^3). THis does have slightl ylower coefficient than the algorithm in part a however.
 
6a: In the first for loop, the inside has a time complexity of O(N) because each of the get()'s require, in the worst case, full traversal of N elements while the inserts are done in constant time. This inside is done N times which means you multiply O(N+N), times N giving a complexity for the first loop of O(N^2) becuase you drop all but highest power polynomial. The next thing that takes more than O(1) is the second for loop. This loop has a complexity of O(N^2) becuase it has a get() which takes O(N) and then other O(1) operations, all of this is done N times due to the loop. So becuase there are two O(N^2) parts, and you take the higher of the complexities, the total time complexity is O(N^2).

6b: The first loops body had two statements that take O(1) time, becuase each of the insertBEfores()'s insert a value at the head pointer, which is moved by the outer loop. This is then done N times due to the loop. This implies a time complexity for first loop of (N). The next loop is the same big O, O(N). This means the function as a whole has a time complexity of O(N). This is a better complexity that part A because it combines the steps of finding and inserting
